#include "uart_handler.h"
#include "log_system.h"
#include "settings.h"
#include <Preferences.h>

// UART Pin tanƒ±mlamalarƒ±
#define UART_RX_PIN 4   // IO4 - RX2
#define UART_TX_PIN 14  // IO14 - TX2
#define UART_PORT   Serial2
#define UART_TIMEOUT 3000
#define MAX_RESPONSE_LENGTH 256

// Global deƒüi≈ükenler
static unsigned long lastUARTActivity = 0;
static int uartErrorCount = 0;
bool uartHealthy = true;
String lastResponse = "";
UARTStatistics uartStats = {0, 0, 0, 0, 0, 100.0};

// Buffer temizleme
void clearUARTBuffer() {
    delay(50);
    while (UART_PORT.available()) {
        UART_PORT.read();
        delay(1);
    }
}

// UART istatistiklerini g√ºncelle
void updateUARTStats(bool success) {
    if (success) {
        unsigned long total = uartStats.totalFramesSent + uartStats.totalFramesReceived;
        unsigned long errors = uartStats.frameErrors + uartStats.checksumErrors + uartStats.timeoutErrors;
        if (total > 0) {
            uartStats.successRate = ((float)(total - errors) / (float)total) * 100.0;
        }
    } else {
        uartStats.frameErrors++;
        unsigned long total = uartStats.totalFramesSent + uartStats.totalFramesReceived;
        unsigned long errors = uartStats.frameErrors + uartStats.checksumErrors + uartStats.timeoutErrors;
        if (total > 0) {
            uartStats.successRate = ((float)(total - errors) / (float)total) * 100.0;
        }
    }
}

// UART reset
void resetUART() {
    addLog("üîÑ UART reset ediliyor...", WARN, "UART");
    
    UART_PORT.end();
    delay(200);
    
    pinMode(UART_RX_PIN, INPUT);
    pinMode(UART_TX_PIN, OUTPUT);
    digitalWrite(UART_TX_PIN, HIGH);
    
    UART_PORT.begin(250000, SERIAL_8N1, UART_RX_PIN, UART_TX_PIN);
    delay(200);
    
    clearUARTBuffer();
    
    lastUARTActivity = millis();
    uartErrorCount = 0;
    uartHealthy = true;
    
    addLog("‚úÖ UART reset tamamlandƒ±", SUCCESS, "UART");
    delay(500);
}

// UART ba≈ülatma
void initUART() {
    addLog("üöÄ UART ba≈ülatƒ±lƒ±yor...", INFO, "UART");
    
    pinMode(UART_RX_PIN, INPUT);
    pinMode(UART_TX_PIN, OUTPUT);
    
    UART_PORT.begin(250000, SERIAL_8N1, UART_RX_PIN, UART_TX_PIN);
    
    delay(100);
    clearUARTBuffer();
    
    lastUARTActivity = millis();
    uartErrorCount = 0;
    uartHealthy = true;
    
    addLog("‚úÖ UART ba≈ülatƒ±ldƒ± - TX2: IO" + String(UART_TX_PIN) + 
           ", RX2: IO" + String(UART_RX_PIN) + 
           ", Baud: 250000", SUCCESS, "UART");
    
    testUARTConnection();
}

// UART baƒülantƒ± testi
bool testUARTConnection() {
    addLog("üß™ UART baƒülantƒ±sƒ± test ediliyor...", INFO, "UART");
    
    if (UART_PORT.available()) {
        String response = "";
        while (UART_PORT.available() && response.length() < 50) {
            char c = UART_PORT.read();
            if (c >= 32 && c <= 126) {
                response += c;
            }
        }
        
        if (response.length() > 0) {
            addLog("‚úÖ UART'da mevcut veri: '" + response + "'", SUCCESS, "UART");
            uartHealthy = true;
            lastUARTActivity = millis();
            return true;
        }
    }
    
    if (UART_PORT) {
        addLog("‚úÖ UART portu aktif", SUCCESS, "UART");
        uartHealthy = true;
        return true;
    } else {
        addLog("‚ùå UART portu kapalƒ±", ERROR, "UART");
        uartHealthy = false;
        return false;
    }
}

// G√ºvenli UART okuma
String safeReadUARTResponse(unsigned long timeout) {
    String response = "";
    unsigned long startTime = millis();
    bool dataStarted = false;
    
    while (millis() - startTime < timeout) {
        if (UART_PORT.available()) {
            char c = UART_PORT.read();
            lastUARTActivity = millis();
            uartHealthy = true;
            dataStarted = true;
            
            if (c == '\n' || c == '\r') {
                if (response.length() > 0) {
                    uartStats.totalFramesReceived++;
                    return response;
                }
            } else if (c >= 32 && c <= 126) {
                response += c;
                if (response.length() >= MAX_RESPONSE_LENGTH - 1) {
                    uartStats.totalFramesReceived++;
                    return response;
                }
            }
        } else if (dataStarted) {
            delay(10);
            if (!UART_PORT.available()) {
                if (response.length() > 0) {
                    uartStats.totalFramesReceived++;
                    return response;
                }
            }
        }
        delay(1);
    }
    
    if (response.length() == 0) {
        uartStats.timeoutErrors++;
    }
    
    return response;
}

// √ñzel komut g√∂nderme
bool sendCustomCommand(const String& command, String& response, unsigned long timeout) {
    if (command.length() == 0 || command.length() > 100) {
        return false;
    }
    
    if (!uartHealthy) {
        resetUART();
    }
    
    clearUARTBuffer();
    
    UART_PORT.print(command);
    UART_PORT.flush();
    
    uartStats.totalFramesSent++;
    
    response = safeReadUARTResponse(timeout == 0 ? UART_TIMEOUT : timeout);
    
    bool success = response.length() > 0;
    updateUARTStats(success);
    
    if (!success) {
        uartErrorCount++;
    }
    
    return success;
}

// BaudRate deƒüi≈ütirme
bool changeBaudRate(long baudRate) {
    addLog("ESP32 UART hƒ±zƒ± sabit 250000'de kalƒ±yor, sadece dsPIC'e kod g√∂nderiliyor", INFO, "UART");
    return sendBaudRateCommand(baudRate);
}

// BaudRate komutunu g√∂nder
bool sendBaudRateCommand(long baudRate) {
    String command = "";
    
    switch(baudRate) {
        case 9600:   command = "0Br";   break;
        case 19200:  command = "1Br";  break;
        case 38400:  command = "2Br";  break;
        case 57600:  command = "3Br";  break;
        case 115200: command = "4Br"; break;
        default:
            addLog("Ge√ßersiz baudrate: " + String(baudRate), ERROR, "UART");
            return false;
    }
    
    clearUARTBuffer();
    
    UART_PORT.print(command);
    UART_PORT.flush();
    
    uartStats.totalFramesSent++;
    
    addLog("dsPIC33EP'ye baudrate kodu g√∂nderildi: " + command, INFO, "UART");
    
    String response = safeReadUARTResponse(2000);
    
    if (response == "ACK" || response.indexOf("OK") >= 0) {
        addLog("‚úÖ Baudrate kodu dsPIC33EP tarafƒ±ndan alƒ±ndƒ±", SUCCESS, "UART");
        updateUARTStats(true);
        return true;
    } else if (response.length() > 0) {
        addLog("dsPIC33EP yanƒ±tƒ±: " + response, WARN, "UART");
        updateUARTStats(true);
        return true;
    } else {
        addLog("‚ùå dsPIC33EP'den yanƒ±t alƒ±namadƒ±", ERROR, "UART");
        updateUARTStats(false);
        return false;
    }
}

// ============ YENƒ∞ ARIZA SORGULAMA FONKSƒ∞YONLARI ============

// Toplam arƒ±za sayƒ±sƒ±nƒ± al (AN komutu)
int getTotalFaultCount() {
    clearUARTBuffer();
    
    UART_PORT.print("AN");
    UART_PORT.flush();
    
    uartStats.totalFramesSent++;
    
    addLog("üìä Arƒ±za sayƒ±sƒ± sorgulanƒ±yor (AN komutu)", DEBUG, "UART");
    
    String response = safeReadUARTResponse(2000);
    
    if (response.length() >= 2 && response.charAt(0) == 'A') {
        addLog("üì• Gelen yanƒ±t: " + response, DEBUG, "UART");
        
        // A'dan sonrasƒ±nƒ± sayƒ±ya √ßevir
        String numberStr = response.substring(1);  
        int count = numberStr.toInt();
        
        // 50 - 1 = 49 mantƒ±ƒüƒ±
        int actualFaultCount = count - 1;
        
        if (actualFaultCount >= 0) {
            addLog("‚úÖ Toplam arƒ±za sayƒ±sƒ±: " + String(actualFaultCount), SUCCESS, "UART");
            updateUARTStats(true);
            return actualFaultCount;
        }
    }
    
    addLog("‚ùå Arƒ±za sayƒ±sƒ± alƒ±namadƒ± veya ge√ßersiz format: " + response, ERROR, "UART");
    updateUARTStats(false);
    return 0;
}

// Belirli bir arƒ±za adresini sorgula
bool requestSpecificFault(int faultNumber) {
    clearUARTBuffer();
    
    // Komutu formatla: 00001v, 00002v, ... formatƒ±nda
    char command[10];
    sprintf(command, "%05dv", faultNumber);
    
    UART_PORT.print(command);
    UART_PORT.flush();
    
    uartStats.totalFramesSent++;
    
    addLog("üîç Arƒ±za komutu g√∂nderildi: " + String(command), DEBUG, "UART");
    
    lastResponse = safeReadUARTResponse(3000);
    
    if (lastResponse.length() > 0 && lastResponse != "E") {
        String preview = lastResponse.length() > 50 ? 
                        lastResponse.substring(0, 50) + "..." : 
                        lastResponse;
        addLog("‚úÖ Arƒ±za " + String(faultNumber) + " yanƒ±tƒ±: " + preview, DEBUG, "UART");
        updateUARTStats(true);
        return true;
    } else {
        addLog("‚ùå Arƒ±za " + String(faultNumber) + " i√ßin yanƒ±t alƒ±namadƒ±", ERROR, "UART");
        updateUARTStats(false);
        return false;
    }
}

// ƒ∞lk arƒ±za kaydƒ±nƒ± al (geriye uyumluluk i√ßin)
bool requestFirstFault() {
    return requestSpecificFault(1);
}

// Sonraki arƒ±za kaydƒ±nƒ± al (DEPRECATED - kullanmayƒ±n)
bool requestNextFault() {
    addLog("‚ö†Ô∏è requestNextFault() artƒ±k kullanƒ±lmƒ±yor. requestSpecificFault() kullanƒ±n.", WARN, "UART");
    return false;
}

// Son yanƒ±tƒ± al
String getLastFaultResponse() {
    return lastResponse;
}

// Test komutu g√∂nder
bool sendTestCommand(const String& testCmd) {
    clearUARTBuffer();
    
    UART_PORT.print(testCmd);
    UART_PORT.flush();
    
    addLog("üß™ Test komutu g√∂nderildi: " + testCmd, DEBUG, "UART");
    
    String response = safeReadUARTResponse(3000);
    
    if (response.length() > 0) {
        addLog("üì° Test yanƒ±tƒ±: " + response, DEBUG, "UART");
        return true;
    } else {
        addLog("‚ùå Test komutu i√ßin yanƒ±t yok", WARN, "UART");
        return false;
    }
}

// UART saƒülƒ±k kontrol√º
void checkUARTHealth() {
    static unsigned long lastHealthCheck = 0;
    
    if (millis() - lastHealthCheck < 30000) {
        return;
    }
    lastHealthCheck = millis();
    
    // 5 dakika sessizlik kontrol√º
    if (millis() - lastUARTActivity > 300000) {
        if (uartHealthy) {
            addLog("‚ö†Ô∏è UART 5 dakikadƒ±r sessiz", WARN, "UART");
            uartHealthy = false;
        }
    }
    
    // √áok fazla hata varsa reset
    if (uartErrorCount > 5) {
        addLog("üîÑ √áok fazla UART hatasƒ± (" + String(uartErrorCount) + "), reset yapƒ±lƒ±yor...", WARN, "UART");
        resetUART();
    }
    
    // Periyodik test
    if (!uartHealthy) {
        addLog("ü©∫ UART saƒülƒ±k testi yapƒ±lƒ±yor...", INFO, "UART");
        testUARTConnection();
    }
}

// UART durumunu al
String getUARTStatus() {
    String status = "UART Durumu:\n";
    status += "Saƒülƒ±k: " + String(uartHealthy ? "‚úÖ ƒ∞yi" : "‚ùå K√∂t√º") + "\n";
    status += "Son Aktivite: " + String((millis() - lastUARTActivity) / 1000) + " saniye √∂nce\n";
    status += "Hata Sayƒ±sƒ±: " + String(uartErrorCount) + "\n";
    status += "Ba≈üarƒ± Oranƒ±: " + String(uartStats.successRate, 1) + "%\n";
    status += "G√∂nderilen: " + String(uartStats.totalFramesSent) + "\n";
    status += "Alƒ±nan: " + String(uartStats.totalFramesReceived) + "\n";
    status += "Timeout: " + String(uartStats.timeoutErrors);
    return status;
}